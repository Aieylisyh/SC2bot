from sc2.bot_ai import BotAI, Race
from sc2.data import Race, Difficulty
from sc2.player import Bot, Computer
from sc2.position import Point2
from sc2.unit import Unit
from sc2.units import Units
from sc2.ids.unit_typeid import UnitTypeId
from sc2.constants import *
from sc2.ids.ability_id import AbilityId
from sc2 import maps
from sc2.bot_ai import BotAI
from sc2.ids.buff_id import BuffId
from bot.BotSubModule.Mission.MissionPrototypes.MissionPrototype import MissionPrototype
import asyncio
import enum
from bot.BotSubModule.bot_mainStrategy import bot_mainStrategy
from bot.BotSubModule.bot_tactics import bot_tactics
from bot.BotSubModule.bot_unitSelection import bot_unitSelection

# DO NOT EDIT!
# This file was automatically generated by "generate_ids.py"


class MissionState(enum.Enum):
    Null = 0  # not in game
    Pending = 1  # prepare
    Doing = 2  # current
    Done = 3  # finished
    # discarded?

    def __repr__(self):
        return f"MissionState.{self.name}"


class Progontanist:
    p: Unit
    log: str = ""  # temp log for any thing that want to save
    targetPos: Point2
    targetUnit: Unit
    targetUnits: Units

    # targetDuration: float
    # targetAmount: int
    # startIteraction: int

    def __init__(self, p: Unit):
        self.p = p


class MissionInstance:
    state: MissionState = MissionState.Null
    id: str = ""
    proto: MissionPrototype
    layer: int
    piority: int = 1
    progontanists: list[Progontanist]
    # triggers if score>100
    # if this is in pending list, this decide whether to start this
    # if this is in current list, this decide whether to pending another mission of this kind
    positiveScore: int = 0
    # triggers if score>100
    # if this is in pending list, this decide whether to discard this
    # if this is in current list, this decide whether to end this
    negativeScore: int = 0

    targetPosition: Point2
    homePosition: Point2
    mainStrategy: bot_mainStrategy
    tactics: bot_tactics
    unitSelection: bot_unitSelection
    iter: int
    result: str = ""  # TODO fail very suc...
    log: str = ""  # temp log for any thing that want to save

    def __init__(self, bot: BotAI, mp: MissionPrototype):
        self.bot = bot
        self.proto = mp
        self.Initialize()

    def Initialize(self):
        self.id = self.proto.id
        self.unitSelection = bot_unitSelection(self.bot)
        self.tactics = bot_tactics(self.bot)
        self.mainStrategy = bot_mainStrategy(self.bot)
        self.progontanists = []
        # print("mission instance " + str(self.proto))

    async def CheckState(self) -> MissionState:
        if self.state == MissionState.Pending:
            self.CheckStartMission()
        elif self.state == MissionState.Doing:
            await self.Do()
            self.CheckEndMission()
            self.CheckAppendMission()
        elif self.state == MissionState.Done:
            a = 1
            # TODO recycle
        return self.state

    async def Do(self):
        self.iter += 1
        # unit info is cached, if not update, some attri like position will not change
        if self.progontanists:
            for p in self.progontanists.copy():
                if not p.p:
                    self.progontanists.remove(p)
                    continue
                if p.p.is_memory:
                    tag = p.p.tag
                    p.p = self.bot.units.find_by_tag(tag)
                    if not p.p:
                        self.progontanists.remove(p)
                        continue

        if self.proto.goalDesc == "sneakily kill appropriate units, prefer workers":
            await self.AdeptRush()

    def CheckStartMission(self):
        bot = self.bot
        if self.proto.startCondition == "once only, we have 2 adept":
            myForces = bot.units(UnitTypeId.ADEPT).ready
            if myForces.amount >= 2:
                self.positiveScore = 100
                self.state = MissionState.Doing
                return

    def CheckAppendMission(self):
        a = 1
        # print("TODO")

    def CheckEndMission(self):
        a = 1
        # print("TODO")

    async def AdeptRush(self):
        bot = self.bot
        # sent adepts out
        if self.log == "":
            myForces = self.unitSelection.GetUnits(False).ready
            adepts = myForces.filter(lambda unit: unit.type_id == UnitTypeId.ADEPT)
            for adept in adepts:
                p: Progontanist = Progontanist(adept)
                p.log = "go"
                self.progontanists += [p]

            self.homePosition = bot.start_location
            self.log = "doing"
            self.targetPosition = bot.enemy_start_locations[0].position
            print("AdeptRush!")
            await bot.chat_send("Faith?")

        # let adepts go and fight
        elif self.log == "doing":
            if len(self.progontanists) <= 0:
                self.state = MissionState.Done
                return
            self.RemoveInvalidProgontanists()
            # await self.Act_shades()
            await self.CheckState_Adepts()

    def RemoveInvalidProgontanists(self):
        for p in self.progontanists.copy():
            if not p.p:
                self.progontanists.remove(p)
                continue

    async def Act_shades(self):
        shades = self.bot.units(UnitTypeId.ADEPTPHASESHIFT).ready
        if shades and shades.amount > 0:
            for shade in shades:
                await self.Act_Shade(shade)

    async def Act_Shade(self, shade: Unit):
        print("Act_Shade " + str(shade))

    async def CheckState_Adepts(self):
        for p in self.progontanists:
            await self.CheckState_Adept(p)
            await self.Act_Adept(p)

    async def CheckState_Adept(self, p: Progontanist):
        adept = p.p
        bot = self.bot
        enes: Units = self.unitSelection.GetUnits(True, workers=True).ready
        involvedEnes = self.unitSelection.UnitsInRangeOfUnit(adept, enes, 14)

        if not involvedEnes:
            if p.log == "go":
                return
            elif p.log == "attack":
                p.log = "go"
                return

        if p.log == "retreat":
            return
        ########################## helper ################################
        e: Unit = involvedEnes.first
        # e in enes
        # workers = enes.filter( lambda unit: unit.type_id  in {UnitTypeId.PROBE, UnitTypeId.SCV, UnitTypeId.DRONE}   )
        ########################## helper ################################

        preys = involvedEnes.filter(
            lambda unit: unit.is_light and (unit.shield + unit.health) < 60
        )
        threatEnes = involvedEnes.filter(
            lambda unit: unit.can_attack_ground
            # and (not unit.is_gathering and not unit.is_returning)
            # and (not unit in {UnitTypeId.PROBE, UnitTypeId.SCV, UnitTypeId.DRONE})
        )

        threat = 0
        for threatEne in threatEnes:
            dps = threatEne.calculate_dps_vs_target(
                adept, include_overkill_damage=False
            )
            threat += dps * self.GetThreatRatioByDistance(adept, threatEne)
        if threat > 0:
            # print("threat to Adept: " + str(threat))
            if threat >= 15:
                # dangerous
                abilities = await self.bot.get_available_abilities(adept)
                if (
                    p.log == "go"
                    and not AbilityId.ADEPTPHASESHIFT_ADEPTPHASESHIFT in abilities
                ):
                    await self.Run_Adept(p.p, self.homePosition, 50, False)
                    # print("shade in cd, temp retreat")
                    return
                elif p.log == "attack":
                    if threat >= 25:
                        print(str(adept) + " attack to retreat")
                        p.log = "retreat"
                        return
                else:
                    print(str(adept) + " " + p.log + " to retreat")
                    p.log = "retreat"
                    return

        insight_targets = self.unitSelection.UnitsInRangeOfUnit(adept, preys, 10)
        if insight_targets:
            print(str(adept) + " to attack")
            p.log = "attack"
            return

    def GetThreatRatioByDistance(self, u: Unit, threatEne: Unit):
        bot = self.bot
        threatRange = max(4, threatEne.ground_range)
        dist = bot._distance_pos_to_pos(threatEne.position, u.position)
        outOfThreatDist = dist - threatRange
        threatDelay = 0
        if outOfThreatDist > 0:
            threatDelay = outOfThreatDist / threatEne.movement_speed
        threatRatio = 0.1
        if threatDelay <= 1:
            threatRatio = 1.0
        elif threatDelay <= 2:
            threatRatio = 0.8
        elif threatDelay <= 3:
            threatRatio = 0.6
        elif threatDelay <= 4:
            threatRatio = 0.3
        elif threatDelay <= 5:
            threatRatio = 0.2
        elif threatDelay <= 6:
            threatRatio = 0.15
        if threatEne.type_id in {
            UnitTypeId.PROBE,
            UnitTypeId.SCV,
            UnitTypeId.DRONE,
        }:
            if dist > 1.8:
                threatRatio = 0
        return threatRatio

    async def Act_Adept(self, p: Progontanist):
        if p.log == "go":
            await self.Run_Adept(p.p, self.targetPosition, 35, True, 0.35)
        elif p.log == "attack":
            await self.Run_Adept(p.p, self.targetPosition, 18, False, 0.6)
        elif p.log == "retreat":
            await self.Run_Adept(p.p, self.homePosition, 35, True, 0.25)
            if self.bot._distance_pos_to_pos(p.p.position, self.homePosition) < 25:
                self.progontanists.remove(p)

    async def Run_Adept(
        self,
        adept: Unit,
        targetPos,
        attackBtwValue: float = 0,  # 0 no attack, higher value is about attack good targets only（one shot or can deal higher damage）
        allow_PHASESHIFT: bool = True,
        cdTreshold: float = 0.3,
    ):
        if allow_PHASESHIFT:
            await self.PhaseShiftAdept(adept, targetPos)
        if attackBtwValue > 0:
            info = self.tactics.GetGoodAttackInfo(adept, cdTreshold, onlyShots=3)
            if info[0]:
                print("info attackBtw " + str(info[2]))
                if info[2] > attackBtwValue:
                    adept.attack(info[1])
                    print(str(adept) + " attack " + str(info[1]))
                    return

        # print(str(adept) + " move")
        adept.move(targetPos)

    async def PhaseShiftAdept(self, adept: Unit, p: Point2):
        abilities = await self.bot.get_available_abilities(adept)
        if AbilityId.ADEPTPHASESHIFT_ADEPTPHASESHIFT in abilities:
            adept(
                AbilityId.ADEPTPHASESHIFT_ADEPTPHASESHIFT,
                target=p,
                queue=False,
            )
            print(
                "use PHASESHIFT shade: " + str(adept.position) + " by " + str(adept.tag)
            )
