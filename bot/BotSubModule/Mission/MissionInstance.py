from sc2.bot_ai import BotAI, Race
from sc2.data import Race, Difficulty
from sc2.player import Bot, Computer
from sc2.position import Point2
from sc2.unit import Unit
from sc2.units import Units
from sc2.ids.unit_typeid import UnitTypeId
from sc2.constants import *
from sc2.ids.ability_id import AbilityId
from sc2 import maps
from sc2.bot_ai import BotAI
from sc2.ids.buff_id import BuffId
from bot.BotSubModule.Mission.MissionPrototypes.MissionPrototype import MissionPrototype
import asyncio
import enum
from bot.BotSubModule.bot_mainStrategy import bot_mainStrategy
from bot.BotSubModule.bot_tactics import bot_tactics
from bot.BotSubModule.bot_unitSelection import bot_unitSelection

# DO NOT EDIT!
# This file was automatically generated by "generate_ids.py"


class MissionState(enum.Enum):
    Null = 0  # not in game
    Pending = 1  # prepare
    Doing = 2  # current
    Done = 3  # finished
    # discarded?

    def __repr__(self):
        return f"MissionState.{self.name}"


class Progontanist:
    p: Unit
    log: str = ""  # temp log for any thing that want to save
    targetPos: Point2
    targetUnit: Unit
    targetUnits: Units

    # targetDuration: float
    # targetAmount: int
    # startIteraction: int

    def __init__(self, p: Unit):
        self.p = p


class MissionInstance:
    state: MissionState = MissionState.Null
    id: str = ""
    proto: MissionPrototype
    layer: int
    piority: int = 1
    progontanists: list[Progontanist]
    # triggers if score>100
    # if this is in pending list, this decide whether to start this
    # if this is in current list, this decide whether to pending another mission of this kind
    positiveScore: int = 0
    # triggers if score>100
    # if this is in pending list, this decide whether to discard this
    # if this is in current list, this decide whether to end this
    negativeScore: int = 0

    targetPosition: Point2
    homePosition: Point2
    mainStrategy: bot_mainStrategy
    tactics: bot_tactics
    unitSelection: bot_unitSelection
    iter: int
    result: str = ""  # TODO fail very suc...
    log: str = ""  # temp log for any thing that want to save

    def __init__(self, bot: BotAI, mp: MissionPrototype):
        self.bot = bot
        self.proto = mp
        self.Initialize()

    def Initialize(self):
        self.id = self.proto.id
        self.unitSelection = bot_unitSelection(self.bot)
        self.tactics = bot_tactics(self.bot)
        self.mainStrategy = bot_mainStrategy(self.bot)
        self.progontanists = []
        # print("mission instance " + str(self.proto))

    async def CheckState(self) -> MissionState:
        if self.state == MissionState.Pending:
            self.CheckStartMission()
        elif self.state == MissionState.Doing:
            await self.Do()
            self.CheckEndMission()
            self.CheckAppendMission()
        elif self.state == MissionState.Done:
            a = 1
            # TODO recycle
        return self.state

    async def Do(self):
        self.iter += 1
        if self.proto.goalDesc == "sneakily kill appropriate units, prefer workers":
            await self.AdeptRush()

    def CheckStartMission(self):
        bot = self.bot
        if self.proto.startCondition == "once only, we have 2 adept":
            myForces = bot.units(UnitTypeId.ADEPT).ready
            if myForces.amount >= 2:
                self.positiveScore = 100
                self.state = MissionState.Doing
                return

    def CheckAppendMission(self):
        a = 1
        # print("TODO")

    def CheckEndMission(self):
        a = 1
        # print("TODO")

    async def AdeptRush(self):
        bot = self.bot
        if self.log == "":
            myForces = self.unitSelection.GetUnits(False).ready
            adepts = myForces.filter(lambda unit: unit.type_id == UnitTypeId.ADEPT)
            for adept in adepts:
                p: Progontanist = Progontanist(adept)
                p.log = "go"
                self.progontanists += [p]

            self.homePosition = bot.start_location
            self.log = "doing"
            self.targetPosition = bot.enemy_start_locations[0].position
            print("AdeptRush!")
            await bot.chat_send("AdeptRush!")

        elif self.log == "doing":
            if len(self.progontanists) <= 0:
                self.state = MissionState.Done
                return

            for p in self.progontanists:
                self.CheckSurrounding_Adept(p)

            for p in self.progontanists.copy():
                if not p.p:
                    self.progontanists.remove(p)
                    continue

                await self.Act_Adept(p)

                if self.log == "retreat":
                    self.progontanists.remove(p)

    def CheckSurrounding_Adept(self, p: Progontanist):
        adept = p.p
        bot = self.bot
        enes: Units = self.unitSelection.GetUnits(True).ready
        enes = self.unitSelection.UnitsInRangeOfUnit(adept, enes, 14)

        if not enes:
            if p.log == "go":
                return
            elif p.log == "attack":
                p.log = "go"
                return
            elif p.log == "retreat":
                return
        ########################## helper ################################
        e: Unit = enes.first
        # e in enes
        # workers = enes.filter( lambda unit: unit.type_id  in {UnitTypeId.PROBE, UnitTypeId.SCV, UnitTypeId.DRONE}   )
        ########################## helper ################################

        targetUnits = enes.filter(
            lambda unit: unit.is_light and (unit.shield + unit.health) < 60
        )
        threatsUnits = enes.filter(
            lambda unit: unit.can_attack_ground and (not unit in targetUnits)
        )

        threat = 0
        for threatEne in threatsUnits:
            ThreatRange = max(6, threatEne.ground_range)
            dist = bot.distance_math_hypot(threatEne, adept)
            outOfThreatDist = dist - ThreatRange
            dps = threatEne.calculate_dps_vs_target(
                adept, include_overkill_damage=False
            )
            threatAttackMeTime = 0
            if outOfThreatDist > 0:
                threatAttackMeTime = outOfThreatDist / threatEne.movement_speed
            if threatAttackMeTime <= 0.5:
                threat += dps
            elif threatAttackMeTime <= 2:
                threat += dps * 0.6
            elif threatAttackMeTime <= 4:
                threat += dps * 0.3
            else:
                threat += dps * 0.1
        if threat > 0:
            print("CheckSurrounding_Adept threat: " + str(threat))
        if threat >= 10:
            # dangerous
            p.log = "retreat"
            return

        insight_targets = self.unitSelection.UnitsInRangeOfUnit(adept, targetUnits, 9.5)
        if insight_targets:
            p.log = "attack"
            return

    async def Act_Adept(self, p: Progontanist):
        if p.log == "go":
            await self.Run_Adept(p.p, self.targetPosition, 30, True)
        elif p.log == "attack":
            await self.Run_Adept(p.p, self.targetPosition, 16, False)
        elif p.log == "retreat":
            await self.Run_Adept(p.p, self.homePosition, 30, False)

    async def Run_Adept(
        self,
        adept: Unit,
        targetPos,
        attackBtwValue: float = 0,  # 0 no attack,>25 is about attack good targets only
        allow_PHASESHIFT: bool = True,
    ):
        if allow_PHASESHIFT:
            abilities = await self.bot.get_available_abilities(adept)
            if AbilityId.ADEPTPHASESHIFT_ADEPTPHASESHIFT in abilities:
                adept(
                    AbilityId.ADEPTPHASESHIFT_ADEPTPHASESHIFT,
                    target=self.targetPosition,
                    queue=False,
                )

        if attackBtwValue > 0:
            info = self.tactics.GetGoodAttackInfo(adept, 0.4, onlyShots=3)
            if info[0]:
                print("Run_Adept attackBtw " + str(info[2]))
                print(info[1])
                if info[2] > attackBtwValue:
                    adept.attack(info[1])

        adept.move(targetPos)
